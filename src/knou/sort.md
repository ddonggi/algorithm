정렬할 데이터가 배열 A[]와 같이 주어졌을 때 아래 정렬의 수행 과정 각각을 단계별로 보이시오.

1. 선택 정렬 
2. 버블 정렬(왼쪽에서 오른쪽으로 진행)
3. 삽입 정렬 

## 주어진 배열
```
A[] = {20 50 60 30 40 10}
```

### 1. 선택 정렬

선택정렬의 알고리즘

```
n=6
SelectionSort(A[],n){
    for(i=0; i < n-1; i++{ //n-1번 반복
        min=i;
        for (j=i+1; j<n; j++){ //미정렬 부분에서 최솟값 찾기
            if(A[min] > A[j])
                min = j;
            A[i]와 A[min]의 자리 바꿈 //최솟값과 데이터A[i]와 위치 교환
        }
    }
    return (A);
}
```
A[]의 0번 인덱스 부터 시작하므로 i=0, min=0 이다.  
정렬되지 않은 부분과 비교를 시작한다. j는 i+1인 1 부터 시작한다.  
min은 0이므로 A[min]=20, j는 1이므로 A[j]=50이 된다.  
20 보다 50이 크기에 if문에서 아무런 변화가 없다.  
j+1이 되어 j는 2가 되므로 A[j]=60, j가 3일때는 30, j가 4일때는 40 이 되어 마찬가지로 20보다 크기에 min에는 아무런 변화가 없다.  
j가 5가 되면 A[j]=10 이기에, A[min]의 값인 20 보다 작은값이 되어 if문이 참인 경우가 된다.  
min = j의 값인 5 이다.  
A[0] 과 A[min] 의 자리를 바꾼다.  
바꾼 후엔 A[]={10 50 60 30 40 20}이 된다.

위의 알고리즘을 한번 더 반복하면,  
i=1, min=1 , A[min]=50 이 되며, j가 3일 경우 A[j]=30 이고, if문이 참이 된다.  
따라서 min= j의 값인 3이다. 하지만 j가 5일 경우에 A[j] = 20, 현재 최솟값인 A[3]=30 보다 작으므로, if문이 참이 되어 min=5가 된다.
A[1] 과 A[min] 의 자리를 바꾼다.  
바꾼 후엔 A[] = {10 20 60 30 40 50}  

다시 반복한다.  
i=2, min=2, A[min] = 60, j=3일때 A[j] = 30, if문이 참이 된다.  
min=3이 된다. 더 반복해도 if문이 참이 되지 않는다.  
A[2]와 A[min] 의 자리를 바꾼다.  
바꾼 후엔 A[]={10 20 30 60 40 50}

다시 반복과정을 거치면  
i=3, min=3, A[min]= 60, j=4일때 A[j] = 40, if문이 참이 된다.  
min=4 가 된다. 더 반복해도 if문이 참이 되지 않는다.  
A[3] 과 A[min] 의 자리를 바꾼다.  
A[] = {10 20 30 40 60 50}  

다시 반복한다.  
i=4, min=4, A[min]=60, j=5일때 A[j]=50, if문이 참이 된다.  
min=5 가 된다.  
A[4] 와 A[min] 의 자리를 바꾼다.  
A[] = {10 20 30 40 50 60} 이 된다.  
